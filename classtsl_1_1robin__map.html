<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>robin-map: tsl::robin_map&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">robin-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1robin__map.html">robin_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1robin__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tsl::robin_map&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="robin__map_8h_source.html">robin_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2f750def47c878bdd0beba8e145253d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a3658ab0dd60d254d7d0f6a414a1417b5">ht::key_type</a></td></tr>
<tr class="separator:af2f750def47c878bdd0beba8e145253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a0e27aa133836f0309c138023b8a86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a63a0e27aa133836f0309c138023b8a86">mapped_type</a> = T</td></tr>
<tr class="separator:a63a0e27aa133836f0309c138023b8a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c98b5c3e7c8224c250aea3c39a13f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#aa55c9015ef4019a93c39298a5a58c5bf">ht::value_type</a></td></tr>
<tr class="separator:a79c98b5c3e7c8224c250aea3c39a13f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa075954920d6a163065dcb3151fb1b39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a0ca2639791ec1009a9ee71ebfa68bfef">ht::size_type</a></td></tr>
<tr class="separator:aa075954920d6a163065dcb3151fb1b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6dd2db83064c66939c1c08ca150105"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aca6dd2db83064c66939c1c08ca150105">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a0902200119ac90388270a886baf6aac2">ht::difference_type</a></td></tr>
<tr class="separator:aca6dd2db83064c66939c1c08ca150105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c526c0025823aa7ae4f89d3e9b083b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a47c526c0025823aa7ae4f89d3e9b083b">hasher</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#ae95d916fb321942b56e6aedbaba67a0d">ht::hasher</a></td></tr>
<tr class="separator:a47c526c0025823aa7ae4f89d3e9b083b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb3252660090156ae403291467ba54f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#abbb3252660090156ae403291467ba54f">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a68e60946bfa1ab8af6ccba34d621d9e2">ht::key_equal</a></td></tr>
<tr class="separator:abbb3252660090156ae403291467ba54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063439ab8eab73c83977773ba5b72733"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a063439ab8eab73c83977773ba5b72733">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a3bb2c8d0e7b43c564b51310cffe4fdb6">ht::allocator_type</a></td></tr>
<tr class="separator:a063439ab8eab73c83977773ba5b72733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7dc63caeb8f642e537ed6a25e77852"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a5c7dc63caeb8f642e537ed6a25e77852">reference</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a05f85a346a51816d50911e2e20c0df03">ht::reference</a></td></tr>
<tr class="separator:a5c7dc63caeb8f642e537ed6a25e77852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e56672c5b968ac865b79ed346a01aa9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a8e56672c5b968ac865b79ed346a01aa9">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a1399bd1280cd3615562619349f2ce032">ht::const_reference</a></td></tr>
<tr class="separator:a8e56672c5b968ac865b79ed346a01aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d22ffaaf40ac157275a68082e071f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a22d22ffaaf40ac157275a68082e071f0">pointer</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a6d050ee939e0c279d088712ee2b550fb">ht::pointer</a></td></tr>
<tr class="separator:a22d22ffaaf40ac157275a68082e071f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11f50b055d127a1bf50c9bfe12b9100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ac11f50b055d127a1bf50c9bfe12b9100">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a6c168ba2906e8a8c030480bd95ea308a">ht::const_pointer</a></td></tr>
<tr class="separator:ac11f50b055d127a1bf50c9bfe12b9100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76c11b77a9d571c6fe86c2a0f120f6b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a7a5a16d319f0f389f2daac39841ad108">ht::iterator</a></td></tr>
<tr class="separator:ab76c11b77a9d571c6fe86c2a0f120f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e02928b9e0e694517b7ff9f6fd0db3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a6b2144cc80c9e7c63b59323855ce4a57">ht::const_iterator</a></td></tr>
<tr class="separator:ab8e02928b9e0e694517b7ff9f6fd0db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2fa0347a40e4f2dd6b31ff1dd5507182"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a2fa0347a40e4f2dd6b31ff1dd5507182">robin_map</a> ()</td></tr>
<tr class="separator:a2fa0347a40e4f2dd6b31ff1dd5507182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716ca16dbb36dfd83e9352fff278b4e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a716ca16dbb36dfd83e9352fff278b4e4">robin_map</a> (<a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a716ca16dbb36dfd83e9352fff278b4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459461132408c7c1a6cc2bca738b6434"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a459461132408c7c1a6cc2bca738b6434">robin_map</a> (<a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a459461132408c7c1a6cc2bca738b6434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ce13ad2d9bf44fb20fcff4748bbb62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a47ce13ad2d9bf44fb20fcff4748bbb62">robin_map</a> (<a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a47ce13ad2d9bf44fb20fcff4748bbb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e056e4e2e0de473198dbf40c7fdf29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ac5e056e4e2e0de473198dbf40c7fdf29">robin_map</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:ac5e056e4e2e0de473198dbf40c7fdf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6a4eae3eb6b009850ee2a579fcdd4"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:aa7a6a4eae3eb6b009850ee2a579fcdd4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aa7a6a4eae3eb6b009850ee2a579fcdd4">robin_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>=<a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#af47d3cbfcda269fae7d0e206e335b628">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:aa7a6a4eae3eb6b009850ee2a579fcdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85df0e7cd1c1b9c1f1a8df6be52a0a9"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ac85df0e7cd1c1b9c1f1a8df6be52a0a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ac85df0e7cd1c1b9c1f1a8df6be52a0a9">robin_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ac85df0e7cd1c1b9c1f1a8df6be52a0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033bba4757bb3e6c4af0a90de7b5eb1e"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a033bba4757bb3e6c4af0a90de7b5eb1e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a033bba4757bb3e6c4af0a90de7b5eb1e">robin_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a033bba4757bb3e6c4af0a90de7b5eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f1fb4eed8b7534f8cad13612eb88f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a405f1fb4eed8b7534f8cad13612eb88f">robin_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt; init, <a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>=<a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#af47d3cbfcda269fae7d0e206e335b628">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a405f1fb4eed8b7534f8cad13612eb88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d9f95e53565fc99de0325e0bb20b3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a85d9f95e53565fc99de0325e0bb20b3c">robin_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt; init, <a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a85d9f95e53565fc99de0325e0bb20b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee16a65b987cb394e8a2a70d6b2e33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#abaee16a65b987cb394e8a2a70d6b2e33">robin_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt; init, <a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:abaee16a65b987cb394e8a2a70d6b2e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8084c9c3068d83283375453f1f3cd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ad8084c9c3068d83283375453f1f3cd0d">operator=</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:ad8084c9c3068d83283375453f1f3cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab634746b4a3a8fd173dc6db08533852f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#a063439ab8eab73c83977773ba5b72733">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab634746b4a3a8fd173dc6db08533852f">get_allocator</a> () const</td></tr>
<tr class="separator:ab634746b4a3a8fd173dc6db08533852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd2bf150b0f054f69d95069fb4bd8a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aafd2bf150b0f054f69d95069fb4bd8a0">begin</a> () noexcept</td></tr>
<tr class="separator:aafd2bf150b0f054f69d95069fb4bd8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99df6cda50764c46c842f7afc6cbf5ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a99df6cda50764c46c842f7afc6cbf5ea">begin</a> () const noexcept</td></tr>
<tr class="separator:a99df6cda50764c46c842f7afc6cbf5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1936d12e48bc9b7e414a0b31153db366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a1936d12e48bc9b7e414a0b31153db366">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a1936d12e48bc9b7e414a0b31153db366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12bbc37c6fe22f29f6b8fd158215984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aa12bbc37c6fe22f29f6b8fd158215984">end</a> () noexcept</td></tr>
<tr class="separator:aa12bbc37c6fe22f29f6b8fd158215984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80ca4d6d8002504580eea79ca008b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aff80ca4d6d8002504580eea79ca008b1">end</a> () const noexcept</td></tr>
<tr class="separator:aff80ca4d6d8002504580eea79ca008b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0961c139eab44bedc958fc62d497af0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a0961c139eab44bedc958fc62d497af0b">cend</a> () const noexcept</td></tr>
<tr class="separator:a0961c139eab44bedc958fc62d497af0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5bf9aee6742e7941410f2a2bf46f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aaa5bf9aee6742e7941410f2a2bf46f52">empty</a> () const noexcept</td></tr>
<tr class="separator:aaa5bf9aee6742e7941410f2a2bf46f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71387cb5cbad0c7730572fafa80a37d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a71387cb5cbad0c7730572fafa80a37d1">size</a> () const noexcept</td></tr>
<tr class="separator:a71387cb5cbad0c7730572fafa80a37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5745b4062e31f77e14e5627d8662042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#af5745b4062e31f77e14e5627d8662042">max_size</a> () const noexcept</td></tr>
<tr class="separator:af5745b4062e31f77e14e5627d8662042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c161d77cceca0e6854845f445bf32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a40c161d77cceca0e6854845f445bf32c">clear</a> () noexcept</td></tr>
<tr class="separator:a40c161d77cceca0e6854845f445bf32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353fc5d02a7305330298463845c4c45a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a353fc5d02a7305330298463845c4c45a">insert</a> (const <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;value)</td></tr>
<tr class="separator:a353fc5d02a7305330298463845c4c45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59addca7c4ad4a78b8b27dcc0f0cba92"><td class="memTemplParams" colspan="2">template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a59addca7c4ad4a78b8b27dcc0f0cba92"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a59addca7c4ad4a78b8b27dcc0f0cba92">insert</a> (P &amp;&amp;value)</td></tr>
<tr class="separator:a59addca7c4ad4a78b8b27dcc0f0cba92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09576d5fe31f4fae22db2205aff98a2e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a09576d5fe31f4fae22db2205aff98a2e">insert</a> (<a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a09576d5fe31f4fae22db2205aff98a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e41eeee036d69286373388b2e7d527d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a0e41eeee036d69286373388b2e7d527d">insert</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, const <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;value)</td></tr>
<tr class="separator:a0e41eeee036d69286373388b2e7d527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703e6029da95b1b521d358fea1b833d3"><td class="memTemplParams" colspan="2">template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a703e6029da95b1b521d358fea1b833d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a703e6029da95b1b521d358fea1b833d3">insert</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, P &amp;&amp;value)</td></tr>
<tr class="separator:a703e6029da95b1b521d358fea1b833d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49f4d657c4746c1aa2955a9fdd7dc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#af49f4d657c4746c1aa2955a9fdd7dc3e">insert</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:af49f4d657c4746c1aa2955a9fdd7dc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2a37b36f02a3c932d3104d4d509f3c"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9d2a37b36f02a3c932d3104d4d509f3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a9d2a37b36f02a3c932d3104d4d509f3c">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a9d2a37b36f02a3c932d3104d4d509f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106ddd82febd8e336e0d9b9f622831c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a106ddd82febd8e336e0d9b9f622831c6">insert</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a106ddd82febd8e336e0d9b9f622831c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a28a4c609f7bc62235fb7f341a1906"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ad0a28a4c609f7bc62235fb7f341a1906"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ad0a28a4c609f7bc62235fb7f341a1906">insert_or_assign</a> (const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:ad0a28a4c609f7bc62235fb7f341a1906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad561f0bfb7c7edd4b0c83640963ff884"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ad561f0bfb7c7edd4b0c83640963ff884"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ad561f0bfb7c7edd4b0c83640963ff884">insert_or_assign</a> (<a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:ad561f0bfb7c7edd4b0c83640963ff884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fec0aa9f69b6821ad54dd98e603c29"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:aa6fec0aa9f69b6821ad54dd98e603c29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aa6fec0aa9f69b6821ad54dd98e603c29">insert_or_assign</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:aa6fec0aa9f69b6821ad54dd98e603c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7c678d553508fb6b41a95bf2d8e169"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:afa7c678d553508fb6b41a95bf2d8e169"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#afa7c678d553508fb6b41a95bf2d8e169">insert_or_assign</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:afa7c678d553508fb6b41a95bf2d8e169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b64b461398e6329845b95135b43c5d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a79b64b461398e6329845b95135b43c5d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a79b64b461398e6329845b95135b43c5d">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a79b64b461398e6329845b95135b43c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733a370756010690bcb547575f044259"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a733a370756010690bcb547575f044259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a733a370756010690bcb547575f044259">emplace_hint</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a733a370756010690bcb547575f044259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d675fdea33544f86ab217e027e555b"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab2d675fdea33544f86ab217e027e555b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab2d675fdea33544f86ab217e027e555b">try_emplace</a> (const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab2d675fdea33544f86ab217e027e555b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9551f5a7a68e0fdb2b44caadb5810d50"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9551f5a7a68e0fdb2b44caadb5810d50"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a9551f5a7a68e0fdb2b44caadb5810d50">try_emplace</a> (<a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a9551f5a7a68e0fdb2b44caadb5810d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a10e8fe41d278d782f2bcb3c095e31"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a33a10e8fe41d278d782f2bcb3c095e31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a33a10e8fe41d278d782f2bcb3c095e31">try_emplace</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a33a10e8fe41d278d782f2bcb3c095e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ec169886662d212b49c041db56bbb2"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:af2ec169886662d212b49c041db56bbb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#af2ec169886662d212b49c041db56bbb2">try_emplace</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> hint, <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:af2ec169886662d212b49c041db56bbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98544e20500a259c842fee1b64030547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a98544e20500a259c842fee1b64030547">erase</a> (<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> pos)</td></tr>
<tr class="separator:a98544e20500a259c842fee1b64030547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd9ad224e8037ae76e0ac30e019a090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aafd9ad224e8037ae76e0ac30e019a090">erase</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> pos)</td></tr>
<tr class="separator:aafd9ad224e8037ae76e0ac30e019a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c1e0653b04ca2423e1e17e33e9593c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ae3c1e0653b04ca2423e1e17e33e9593c">erase</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> first, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> last)</td></tr>
<tr class="separator:ae3c1e0653b04ca2423e1e17e33e9593c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310038e324ae467ba9dd291c20ad9861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a310038e324ae467ba9dd291c20ad9861">erase</a> (const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;key)</td></tr>
<tr class="separator:a310038e324ae467ba9dd291c20ad9861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b8009312272aa1e8d90be3be86847e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab3b8009312272aa1e8d90be3be86847e">erase</a> (const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:ab3b8009312272aa1e8d90be3be86847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe3aa454d9e0fb8a68609e25aaf05d0"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9fe3aa454d9e0fb8a68609e25aaf05d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a9fe3aa454d9e0fb8a68609e25aaf05d0">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:a9fe3aa454d9e0fb8a68609e25aaf05d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2604acb3376e236c5dfd98135676bed6"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2604acb3376e236c5dfd98135676bed6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a2604acb3376e236c5dfd98135676bed6">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a2604acb3376e236c5dfd98135676bed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d0435f4efddfb4b36aa85f72a802d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#af3d0435f4efddfb4b36aa85f72a802d2">swap</a> (<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;other)</td></tr>
<tr class="separator:af3d0435f4efddfb4b36aa85f72a802d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5144f757ec89c1dba6d3a1077f5381c6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a5144f757ec89c1dba6d3a1077f5381c6">at</a> (const Key &amp;key)</td></tr>
<tr class="separator:a5144f757ec89c1dba6d3a1077f5381c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd3c34074cd089168d9bfdaa386131d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a6bd3c34074cd089168d9bfdaa386131d">at</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a6bd3c34074cd089168d9bfdaa386131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317b8b3d358f8e9c32fa814b618089ef"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a317b8b3d358f8e9c32fa814b618089ef">at</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a317b8b3d358f8e9c32fa814b618089ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5603d279d9728ccd144efdd4729bc1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aaf5603d279d9728ccd144efdd4729bc1">at</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aaf5603d279d9728ccd144efdd4729bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36cbae89d57cf6106a821fa8204c483"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad36cbae89d57cf6106a821fa8204c483"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ad36cbae89d57cf6106a821fa8204c483">at</a> (const K &amp;key)</td></tr>
<tr class="separator:ad36cbae89d57cf6106a821fa8204c483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e9ce2552f0413add0e293bf61da33"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a187e9ce2552f0413add0e293bf61da33"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a187e9ce2552f0413add0e293bf61da33">at</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a187e9ce2552f0413add0e293bf61da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7900d6c92b768f0be24dcbf7bef9dd35"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7900d6c92b768f0be24dcbf7bef9dd35"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a7900d6c92b768f0be24dcbf7bef9dd35">at</a> (const K &amp;key) const</td></tr>
<tr class="separator:a7900d6c92b768f0be24dcbf7bef9dd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa005db4142fbf26701b397daa6d3889f"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa005db4142fbf26701b397daa6d3889f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aa005db4142fbf26701b397daa6d3889f">at</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aa005db4142fbf26701b397daa6d3889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9556471a94f4a29ef7546340b26ba31b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a9556471a94f4a29ef7546340b26ba31b">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="separator:a9556471a94f4a29ef7546340b26ba31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d24c33ec82d166664e2d7d946a7449"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a60d24c33ec82d166664e2d7d946a7449">operator[]</a> (Key &amp;&amp;key)</td></tr>
<tr class="separator:a60d24c33ec82d166664e2d7d946a7449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337269a162202c9cab02326bc0f7328b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a337269a162202c9cab02326bc0f7328b">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a337269a162202c9cab02326bc0f7328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95ca7526b1a706450c48d82d165cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a6a95ca7526b1a706450c48d82d165cf1">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a6a95ca7526b1a706450c48d82d165cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403dc9a21916a33fcddec2b26dc70f82"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a403dc9a21916a33fcddec2b26dc70f82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a403dc9a21916a33fcddec2b26dc70f82">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:a403dc9a21916a33fcddec2b26dc70f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89fbf3c62c10d734f4ca5d964951b5f"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab89fbf3c62c10d734f4ca5d964951b5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab89fbf3c62c10d734f4ca5d964951b5f">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:ab89fbf3c62c10d734f4ca5d964951b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545c9b28f4fda024f8b5c84aa3198142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a545c9b28f4fda024f8b5c84aa3198142">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:a545c9b28f4fda024f8b5c84aa3198142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86448e52d481f44ec7ef024496491c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab86448e52d481f44ec7ef024496491c2">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:ab86448e52d481f44ec7ef024496491c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae41a1cb154979273631f771ed697674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aae41a1cb154979273631f771ed697674">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:aae41a1cb154979273631f771ed697674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb07adcb1d536300d200630d316a26f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a2bb07adcb1d536300d200630d316a26f">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a2bb07adcb1d536300d200630d316a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ecee630d4cad32b1b8ed3263959913"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a96ecee630d4cad32b1b8ed3263959913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a96ecee630d4cad32b1b8ed3263959913">find</a> (const K &amp;key)</td></tr>
<tr class="separator:a96ecee630d4cad32b1b8ed3263959913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cd439179fb5cea5c590b772ec7d2ee"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9cd439179fb5cea5c590b772ec7d2ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ad9cd439179fb5cea5c590b772ec7d2ee">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:ad9cd439179fb5cea5c590b772ec7d2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4659aa0553676ddb24497c714aaa7a32"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4659aa0553676ddb24497c714aaa7a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a4659aa0553676ddb24497c714aaa7a32">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:a4659aa0553676ddb24497c714aaa7a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b7887e00abef99d5028d45112990fe"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9b7887e00abef99d5028d45112990fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ae9b7887e00abef99d5028d45112990fe">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:ae9b7887e00abef99d5028d45112990fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af440620fcd954194dc82887a87940c84"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#af440620fcd954194dc82887a87940c84">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:af440620fcd954194dc82887a87940c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5966b11db642a4d331c5e5f76e87ab23"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a5966b11db642a4d331c5e5f76e87ab23">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a5966b11db642a4d331c5e5f76e87ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2c24a3f97b4ad1850bceab2669ef30"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a8c2c24a3f97b4ad1850bceab2669ef30">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a8c2c24a3f97b4ad1850bceab2669ef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeff473502c7f52f8681cbfd96b2bb7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aedeff473502c7f52f8681cbfd96b2bb7">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aedeff473502c7f52f8681cbfd96b2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2089d43f01af1d9143eb81a4226833e6"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2089d43f01af1d9143eb81a4226833e6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a2089d43f01af1d9143eb81a4226833e6">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:a2089d43f01af1d9143eb81a4226833e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e57a9430cf8a3a58f0039642b4e8bd0"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1e57a9430cf8a3a58f0039642b4e8bd0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a1e57a9430cf8a3a58f0039642b4e8bd0">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a1e57a9430cf8a3a58f0039642b4e8bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdced5d8a7c8e54f6a968882e607d3cd"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afdced5d8a7c8e54f6a968882e607d3cd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#afdced5d8a7c8e54f6a968882e607d3cd">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:afdced5d8a7c8e54f6a968882e607d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5614a41a1bf71b3637540f9c6544f02f"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5614a41a1bf71b3637540f9c6544f02f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a5614a41a1bf71b3637540f9c6544f02f">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a5614a41a1bf71b3637540f9c6544f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697bbc070e304c39c72b7c957ce2eaf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a697bbc070e304c39c72b7c957ce2eaf7">bucket_count</a> () const</td></tr>
<tr class="separator:a697bbc070e304c39c72b7c957ce2eaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a26ff911fbbaa9540fc212074361eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a3a26ff911fbbaa9540fc212074361eb5">max_bucket_count</a> () const</td></tr>
<tr class="separator:a3a26ff911fbbaa9540fc212074361eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99c91f5f93aa9b1787edb2e5c3ac50b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab99c91f5f93aa9b1787edb2e5c3ac50b">load_factor</a> () const</td></tr>
<tr class="separator:ab99c91f5f93aa9b1787edb2e5c3ac50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b2323612fffe8e642ceee3a0db8c50"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a53b2323612fffe8e642ceee3a0db8c50">max_load_factor</a> () const</td></tr>
<tr class="separator:a53b2323612fffe8e642ceee3a0db8c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b91c75665772ed91c5669c5bf400c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ac1b91c75665772ed91c5669c5bf400c8">max_load_factor</a> (float ml)</td></tr>
<tr class="separator:ac1b91c75665772ed91c5669c5bf400c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5694ea36caa9d73bffb712ff8bb3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#ab9a5694ea36caa9d73bffb712ff8bb3a">rehash</a> (<a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a337269a162202c9cab02326bc0f7328b">count</a>)</td></tr>
<tr class="separator:ab9a5694ea36caa9d73bffb712ff8bb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb191a8e0a45adba523dc437585d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#affdb191a8e0a45adba523dc437585d22">reserve</a> (<a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html#a337269a162202c9cab02326bc0f7328b">count</a>)</td></tr>
<tr class="separator:affdb191a8e0a45adba523dc437585d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5794e02429626d4b154cc364dd7c710c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#a47c526c0025823aa7ae4f89d3e9b083b">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function</a> () const</td></tr>
<tr class="separator:a5794e02429626d4b154cc364dd7c710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caabe1db5e2f55a8b0f687e721a1162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#abbb3252660090156ae403291467ba54f">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a7caabe1db5e2f55a8b0f687e721a1162">key_eq</a> () const</td></tr>
<tr class="separator:a7caabe1db5e2f55a8b0f687e721a1162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56904d88a160d1881f69e011c9f2c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#aa56904d88a160d1881f69e011c9f2c41">mutable_iterator</a> (<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> pos)</td></tr>
<tr class="separator:aa56904d88a160d1881f69e011c9f2c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6f9f96c16441c4c025b121d944fdc026"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a6f9f96c16441c4c025b121d944fdc026">operator==</a> (const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;rhs)</td></tr>
<tr class="separator:a6f9f96c16441c4c025b121d944fdc026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bce684f2a3901680d3def8db9f92471"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a0bce684f2a3901680d3def8db9f92471">operator!=</a> (const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;rhs)</td></tr>
<tr class="separator:a0bce684f2a3901680d3def8db9f92471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614982dcc0873a246c7cfca6395c6d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1robin__map.html#a614982dcc0873a246c7cfca6395c6d8f">swap</a> (<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;lhs, <a class="el" href="classtsl_1_1robin__map.html">robin_map</a> &amp;rhs)</td></tr>
<tr class="separator:a614982dcc0873a246c7cfca6395c6d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a063439ab8eab73c83977773ba5b72733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063439ab8eab73c83977773ba5b72733">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a063439ab8eab73c83977773ba5b72733">allocator_type</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a3bb2c8d0e7b43c564b51310cffe4fdb6">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8e02928b9e0e694517b7ff9f6fd0db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e02928b9e0e694517b7ff9f6fd0db3">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a6b2144cc80c9e7c63b59323855ce4a57">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac11f50b055d127a1bf50c9bfe12b9100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11f50b055d127a1bf50c9bfe12b9100">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#ac11f50b055d127a1bf50c9bfe12b9100">const_pointer</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a6c168ba2906e8a8c030480bd95ea308a">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e56672c5b968ac865b79ed346a01aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e56672c5b968ac865b79ed346a01aa9">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a8e56672c5b968ac865b79ed346a01aa9">const_reference</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a1399bd1280cd3615562619349f2ce032">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca6dd2db83064c66939c1c08ca150105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6dd2db83064c66939c1c08ca150105">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#aca6dd2db83064c66939c1c08ca150105">difference_type</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a0902200119ac90388270a886baf6aac2">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47c526c0025823aa7ae4f89d3e9b083b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c526c0025823aa7ae4f89d3e9b083b">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a47c526c0025823aa7ae4f89d3e9b083b">hasher</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#ae95d916fb321942b56e6aedbaba67a0d">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab76c11b77a9d571c6fe86c2a0f120f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76c11b77a9d571c6fe86c2a0f120f6b">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a7a5a16d319f0f389f2daac39841ad108">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbb3252660090156ae403291467ba54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb3252660090156ae403291467ba54f">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#abbb3252660090156ae403291467ba54f">key_equal</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a68e60946bfa1ab8af6ccba34d621d9e2">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2f750def47c878bdd0beba8e145253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f750def47c878bdd0beba8e145253d">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a3658ab0dd60d254d7d0f6a414a1417b5">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63a0e27aa133836f0309c138023b8a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a0e27aa133836f0309c138023b8a86">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a63a0e27aa133836f0309c138023b8a86">mapped_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22d22ffaaf40ac157275a68082e071f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d22ffaaf40ac157275a68082e071f0">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a22d22ffaaf40ac157275a68082e071f0">pointer</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a6d050ee939e0c279d088712ee2b550fb">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c7dc63caeb8f642e537ed6a25e77852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7dc63caeb8f642e537ed6a25e77852">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a5c7dc63caeb8f642e537ed6a25e77852">reference</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a05f85a346a51816d50911e2e20c0df03">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa075954920d6a163065dcb3151fb1b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa075954920d6a163065dcb3151fb1b39">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#a0ca2639791ec1009a9ee71ebfa68bfef">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79c98b5c3e7c8224c250aea3c39a13f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c98b5c3e7c8224c250aea3c39a13f9">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> =  typename <a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#aa55c9015ef4019a93c39298a5a58c5bf">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2fa0347a40e4f2dd6b31ff1dd5507182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa0347a40e4f2dd6b31ff1dd5507182">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a716ca16dbb36dfd83e9352fff278b4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716ca16dbb36dfd83e9352fff278b4e4">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a459461132408c7c1a6cc2bca738b6434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459461132408c7c1a6cc2bca738b6434">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ce13ad2d9bf44fb20fcff4748bbb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ce13ad2d9bf44fb20fcff4748bbb62">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5e056e4e2e0de473198dbf40c7fdf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e056e4e2e0de473198dbf40c7fdf29">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7a6a4eae3eb6b009850ee2a579fcdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a6a4eae3eb6b009850ee2a579fcdd4">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#af47d3cbfcda269fae7d0e206e335b628">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac85df0e7cd1c1b9c1f1a8df6be52a0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85df0e7cd1c1b9c1f1a8df6be52a0a9">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a033bba4757bb3e6c4af0a90de7b5eb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033bba4757bb3e6c4af0a90de7b5eb1e">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a405f1fb4eed8b7534f8cad13612eb88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f1fb4eed8b7534f8cad13612eb88f">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__robin__hash_1_1robin__hash.html#af47d3cbfcda269fae7d0e206e335b628">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85d9f95e53565fc99de0325e0bb20b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9f95e53565fc99de0325e0bb20b3c">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abaee16a65b987cb394e8a2a70d6b2e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaee16a65b987cb394e8a2a70d6b2e33">&#9670;&nbsp;</a></span>robin_map() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1robin__map.html">robin_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5144f757ec89c1dba6d3a1077f5381c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5144f757ec89c1dba6d3a1077f5381c6">&#9670;&nbsp;</a></span>at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bd3c34074cd089168d9bfdaa386131d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd3c34074cd089168d9bfdaa386131d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a317b8b3d358f8e9c32fa814b618089ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317b8b3d358f8e9c32fa814b618089ef">&#9670;&nbsp;</a></span>at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf5603d279d9728ccd144efdd4729bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5603d279d9728ccd144efdd4729bc1">&#9670;&nbsp;</a></span>at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ad36cbae89d57cf6106a821fa8204c483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36cbae89d57cf6106a821fa8204c483">&#9670;&nbsp;</a></span>at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a187e9ce2552f0413add0e293bf61da33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e9ce2552f0413add0e293bf61da33">&#9670;&nbsp;</a></span>at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a7900d6c92b768f0be24dcbf7bef9dd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7900d6c92b768f0be24dcbf7bef9dd35">&#9670;&nbsp;</a></span>at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aa005db4142fbf26701b397daa6d3889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa005db4142fbf26701b397daa6d3889f">&#9670;&nbsp;</a></span>at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="aafd2bf150b0f054f69d95069fb4bd8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd2bf150b0f054f69d95069fb4bd8a0">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99df6cda50764c46c842f7afc6cbf5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99df6cda50764c46c842f7afc6cbf5ea">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a697bbc070e304c39c72b7c957ce2eaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697bbc070e304c39c72b7c957ce2eaf7">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1936d12e48bc9b7e414a0b31153db366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1936d12e48bc9b7e414a0b31153db366">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0961c139eab44bedc958fc62d497af0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0961c139eab44bedc958fc62d497af0b">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40c161d77cceca0e6854845f445bf32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c161d77cceca0e6854845f445bf32c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a337269a162202c9cab02326bc0f7328b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337269a162202c9cab02326bc0f7328b">&#9670;&nbsp;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a95ca7526b1a706450c48d82d165cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a95ca7526b1a706450c48d82d165cf1">&#9670;&nbsp;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a403dc9a21916a33fcddec2b26dc70f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403dc9a21916a33fcddec2b26dc70f82">&#9670;&nbsp;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ab89fbf3c62c10d734f4ca5d964951b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89fbf3c62c10d734f4ca5d964951b5f">&#9670;&nbsp;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a79b64b461398e6329845b95135b43c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b64b461398e6329845b95135b43c5d">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a733a370756010690bcb547575f044259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733a370756010690bcb547575f044259">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="aaa5bf9aee6742e7941410f2a2bf46f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5bf9aee6742e7941410f2a2bf46f52">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa12bbc37c6fe22f29f6b8fd158215984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12bbc37c6fe22f29f6b8fd158215984">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff80ca4d6d8002504580eea79ca008b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff80ca4d6d8002504580eea79ca008b1">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af440620fcd954194dc82887a87940c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af440620fcd954194dc82887a87940c84">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5966b11db642a4d331c5e5f76e87ab23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5966b11db642a4d331c5e5f76e87ab23">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a8c2c24a3f97b4ad1850bceab2669ef30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2c24a3f97b4ad1850bceab2669ef30">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedeff473502c7f52f8681cbfd96b2bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeff473502c7f52f8681cbfd96b2bb7">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2089d43f01af1d9143eb81a4226833e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2089d43f01af1d9143eb81a4226833e6">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a1e57a9430cf8a3a58f0039642b4e8bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e57a9430cf8a3a58f0039642b4e8bd0">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="afdced5d8a7c8e54f6a968882e607d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdced5d8a7c8e54f6a968882e607d3cd">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a5614a41a1bf71b3637540f9c6544f02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5614a41a1bf71b3637540f9c6544f02f">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>, <a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a98544e20500a259c842fee1b64030547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98544e20500a259c842fee1b64030547">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafd9ad224e8037ae76e0ac30e019a090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd9ad224e8037ae76e0ac30e019a090">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3c1e0653b04ca2423e1e17e33e9593c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c1e0653b04ca2423e1e17e33e9593c">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a310038e324ae467ba9dd291c20ad9861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310038e324ae467ba9dd291c20ad9861">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3b8009312272aa1e8d90be3be86847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b8009312272aa1e8d90be3be86847e">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a9fe3aa454d9e0fb8a68609e25aaf05d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe3aa454d9e0fb8a68609e25aaf05d0">&#9670;&nbsp;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a2604acb3376e236c5dfd98135676bed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2604acb3376e236c5dfd98135676bed6">&#9670;&nbsp;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a545c9b28f4fda024f8b5c84aa3198142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545c9b28f4fda024f8b5c84aa3198142">&#9670;&nbsp;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab86448e52d481f44ec7ef024496491c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86448e52d481f44ec7ef024496491c2">&#9670;&nbsp;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="aae41a1cb154979273631f771ed697674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae41a1cb154979273631f771ed697674">&#9670;&nbsp;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bb07adcb1d536300d200630d316a26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb07adcb1d536300d200630d316a26f">&#9670;&nbsp;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a96ecee630d4cad32b1b8ed3263959913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ecee630d4cad32b1b8ed3263959913">&#9670;&nbsp;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ad9cd439179fb5cea5c590b772ec7d2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cd439179fb5cea5c590b772ec7d2ee">&#9670;&nbsp;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a4659aa0553676ddb24497c714aaa7a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4659aa0553676ddb24497c714aaa7a32">&#9670;&nbsp;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ae9b7887e00abef99d5028d45112990fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b7887e00abef99d5028d45112990fe">&#9670;&nbsp;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1robin__map.html#a5794e02429626d4b154cc364dd7c710c">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ab634746b4a3a8fd173dc6db08533852f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab634746b4a3a8fd173dc6db08533852f">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#a063439ab8eab73c83977773ba5b72733">allocator_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5794e02429626d4b154cc364dd7c710c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5794e02429626d4b154cc364dd7c710c">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#a47c526c0025823aa7ae4f89d3e9b083b">hasher</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a353fc5d02a7305330298463845c4c45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353fc5d02a7305330298463845c4c45a">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59addca7c4ad4a78b8b27dcc0f0cba92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59addca7c4ad4a78b8b27dcc0f0cba92">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09576d5fe31f4fae22db2205aff98a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09576d5fe31f4fae22db2205aff98a2e">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e41eeee036d69286373388b2e7d527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e41eeee036d69286373388b2e7d527d">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a703e6029da95b1b521d358fea1b833d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703e6029da95b1b521d358fea1b833d3">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af49f4d657c4746c1aa2955a9fdd7dc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49f4d657c4746c1aa2955a9fdd7dc3e">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d2a37b36f02a3c932d3104d4d509f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2a37b36f02a3c932d3104d4d509f3c">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a106ddd82febd8e336e0d9b9f622831c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106ddd82febd8e336e0d9b9f622831c6">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0a28a4c609f7bc62235fb7f341a1906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a28a4c609f7bc62235fb7f341a1906">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad561f0bfb7c7edd4b0c83640963ff884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad561f0bfb7c7edd4b0c83640963ff884">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6fec0aa9f69b6821ad54dd98e603c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fec0aa9f69b6821ad54dd98e603c29">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa7c678d553508fb6b41a95bf2d8e169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7c678d553508fb6b41a95bf2d8e169">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7caabe1db5e2f55a8b0f687e721a1162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caabe1db5e2f55a8b0f687e721a1162">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#abbb3252660090156ae403291467ba54f">key_equal</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab99c91f5f93aa9b1787edb2e5c3ac50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99c91f5f93aa9b1787edb2e5c3ac50b">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a26ff911fbbaa9540fc212074361eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a26ff911fbbaa9540fc212074361eb5">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53b2323612fffe8e642ceee3a0db8c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b2323612fffe8e642ceee3a0db8c50">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1b91c75665772ed91c5669c5bf400c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b91c75665772ed91c5669c5bf400c8">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5745b4062e31f77e14e5627d8662042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5745b4062e31f77e14e5627d8662042">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa56904d88a160d1881f69e011c9f2c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56904d88a160d1881f69e011c9f2c41">&#9670;&nbsp;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a const_iterator to an iterator. </p>

</div>
</div>
<a id="ad8084c9c3068d83283375453f1f3cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8084c9c3068d83283375453f1f3cd0d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1robin__map.html#a79c98b5c3e7c8224c250aea3c39a13f9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9556471a94f4a29ef7546340b26ba31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9556471a94f4a29ef7546340b26ba31b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d24c33ec82d166664e2d7d946a7449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d24c33ec82d166664e2d7d946a7449">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9a5694ea36caa9d73bffb712ff8bb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a5694ea36caa9d73bffb712ff8bb3a">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="affdb191a8e0a45adba523dc437585d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb191a8e0a45adba523dc437585d22">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71387cb5cbad0c7730572fafa80a37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71387cb5cbad0c7730572fafa80a37d1">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#aa075954920d6a163065dcb3151fb1b39">size_type</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3d0435f4efddfb4b36aa85f72a802d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d0435f4efddfb4b36aa85f72a802d2">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2d675fdea33544f86ab217e027e555b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d675fdea33544f86ab217e027e555b">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9551f5a7a68e0fdb2b44caadb5810d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9551f5a7a68e0fdb2b44caadb5810d50">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33a10e8fe41d278d782f2bcb3c095e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a10e8fe41d278d782f2bcb3c095e31">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2ec169886662d212b49c041db56bbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ec169886662d212b49c041db56bbb2">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1robin__map.html#ab76c11b77a9d571c6fe86c2a0f120f6b">iterator</a> <a class="el" href="classtsl_1_1robin__map.html">tsl::robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#ab8e02928b9e0e694517b7ff9f6fd0db3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html#af2f750def47c878bdd0beba8e145253d">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0bce684f2a3901680d3def8db9f92471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bce684f2a3901680d3def8db9f92471">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f9f96c16441c4c025b121d944fdc026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9f96c16441c4c025b121d944fdc026">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a614982dcc0873a246c7cfca6395c6d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614982dcc0873a246c7cfca6395c6d8f">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, class GrowthPolicy  = tsl::power_of_two_growth_policy_rh&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1robin__map.html">robin_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="robin__map_8h_source.html">robin_map.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
